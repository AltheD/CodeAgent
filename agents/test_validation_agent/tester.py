"""
测试执行与AI生成脚本工具集
"""

import asyncio
import json
import os
import subprocess
from typing import Dict, Any


class UnitTester:
    def __init__(self, config: Dict[str, Any]):
        self.config = config

    async def generate_tests_with_ai(self, project_path: str, fix_result: Dict[str, Any] | None) -> None:
        # 预留：可调用外部AI服务生成测试；此处写入占位文件以标记
        ai_dir = os.path.join(project_path, "ai_tests")
        os.makedirs(ai_dir, exist_ok=True)
        meta_path = os.path.join(ai_dir, "generation_meta.json")
        payload = {"hint": "auto-generated by ai", "fix_result": fix_result}
        with open(meta_path, "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)

    async def run_tests(self, project_path: str, target_file: str = None) -> Dict[str, Any]:
        """
        运行测试
        Args:
            project_path: 项目路径
            target_file: 目标测试文件（可选），如果指定则只测试该文件
        """
        # 优先使用 pytest
        try:
            if target_file:
                # 如果指定了目标文件，只测试该文件
                proc = await asyncio.create_subprocess_exec(
                    "pytest", "-q", target_file, cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
            else:
                # 测试整个项目
                proc = await asyncio.create_subprocess_exec(
                    "pytest", "-q", cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
            stdout, stderr = await proc.communicate()
            passed = proc.returncode == 0
            return {
                "passed": passed,
                "returncode": proc.returncode,
                "stdout": stdout.decode("utf-8", errors="ignore").strip(),
                "stderr": stderr.decode("utf-8", errors="ignore").strip(),
            }
        except FileNotFoundError:
            # 回退到 unittest
            if target_file:
                # 如果指定了目标文件，只测试该文件
                # 将文件路径转换为模块路径（例如：tests/test_file.py -> tests.test_file）
                module_path = target_file.replace('\\', '/').replace('/', '.').replace('.py', '')
                proc = await asyncio.create_subprocess_exec(
                    "python", "-m", "unittest", module_path, "-v",
                    cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
            else:
                # 测试整个项目
                proc = await asyncio.create_subprocess_exec(
                    "python", "-m", "unittest", "discover", "-v",
                    cwd=project_path,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
            stdout, stderr = await proc.communicate()
            passed = proc.returncode == 0
            return {
                "passed": passed,
                "returncode": proc.returncode,
                "stdout": stdout.decode("utf-8", errors="ignore").strip(),
                "stderr": stderr.decode("utf-8", errors="ignore").strip(),
            }

    async def calculate_coverage(self, project_path: str) -> int:
        # 使用 coverage 进行简单覆盖率计算（行覆盖率近似）
        try:
            # 首先尝试使用 coverage 工具
            run_proc = await asyncio.create_subprocess_exec(
                "coverage", "run", "-m", "pytest", "-q",
                cwd=project_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            await run_proc.communicate()

            report_proc = await asyncio.create_subprocess_exec(
                "coverage", "report",
                cwd=project_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, _ = await report_proc.communicate()
            text = stdout.decode("utf-8", errors="ignore")
            # 简单解析最后一行的 TOTAL 百分比
            percent = 0
            for line in text.splitlines():
                if line.strip().startswith("TOTAL"):
                    parts = [p for p in line.split(" ") if p]
                    if parts and parts[-1].endswith("%"):
                        try:
                            percent = int(float(parts[-1].strip("%")))
                        except Exception:
                            percent = 0
            return int(percent)
        except FileNotFoundError:
            # 如果没有 coverage 工具，使用简化的覆盖率估算
            return await self._estimate_coverage_simple(project_path)
        except Exception:
            # 其他错误也使用简化估算
            return await self._estimate_coverage_simple(project_path)
    
    async def _estimate_coverage_simple(self, project_path: str) -> int:
        """简化的覆盖率估算（当没有coverage工具时使用）"""
        try:
            # 计算项目中的Python文件数量
            python_files = []
            for root, dirs, files in os.walk(project_path):
                # 跳过测试目录和__pycache__目录
                if 'test' in root.lower() or '__pycache__' in root:
                    continue
                for file in files:
                    if file.endswith('.py') and not file.startswith('test_'):
                        python_files.append(os.path.join(root, file))
            
            # 计算测试文件数量
            test_files = []
            for root, dirs, files in os.walk(project_path):
                for file in files:
                    if (file.startswith('test_') or file.startswith('ai_generated_') or file.startswith('ai_test_')) and file.endswith('.py'):
                        test_files.append(os.path.join(root, file))
            
            # 简单的覆盖率估算：如果有测试文件，假设有一定的覆盖率
            if len(test_files) > 0 and len(python_files) > 0:
                # 基于测试文件与源代码文件的比例估算覆盖率
                ratio = min(len(test_files) / len(python_files), 1.0)
                # 假设每个测试文件能覆盖60-80%的代码
                estimated_coverage = int(ratio * 70)  # 70%作为基础覆盖率
                return min(estimated_coverage, 100)
            elif len(test_files) > 0:
                # 如果有测试文件但没有源代码文件，假设覆盖率较高
                return 85
            else:
                return 0
                
        except Exception:
            return 0


class IntegrationTester:
    def __init__(self, config: Dict[str, Any]):
        self.config = config

    async def run_tests(self, project_path: str) -> Dict[str, Any]:
        # 约定：若存在 tests/integration 目录则运行 pytest 指定路径
        target_dir = os.path.join(project_path, "tests", "integration")
        if not os.path.isdir(target_dir):
            return {"passed": True, "skipped": True, "message": "no integration tests"}
        proc = await asyncio.create_subprocess_exec(
            "pytest", target_dir, "-q",
            cwd=project_path,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()
        return {
            "passed": proc.returncode == 0,
            "returncode": proc.returncode,
            "stdout": stdout.decode("utf-8", errors="ignore"),
            "stderr": stderr.decode("utf-8", errors="ignore"),
        }


class PerformanceTester:
    def __init__(self, config: Dict[str, Any]):
        self.config = config

    async def run_tests(self, project_path: str) -> Dict[str, Any]:
        # 简化：占位实现。后续可集成 pytest-benchmark 或 locust
        return {
            "passed": True,
            "metrics": {
                "placeholder_qps": 1000,
                "placeholder_latency_ms_p95": 20,
            },
        }



